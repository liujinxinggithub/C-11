# 一： 创建和等待多个线程
```c++
void myprint(int inum) {
    cout << "myprint线程开始执行了,线程编号=" << inum << endl;
}

int main() {
    //一：创建和等待多个线程
    vector<thread> mythreads;
    // 创建10个线程，入口统一使用myprint
    // a)10线程还行顺序时乱的，和操作系统对内部线程的运行调度机制有关
    // b)使用迭代器创建多个线程的写法需要记忆（对管理大量线程很方便）
    mythreads.reserve(10);
    for (int i = 0; i < 10; ++i) {
        mythreads.emplace_back(myprint, i);
    }

    for (auto &mythread : mythreads) {
        mythread.join();
    }
    cout << "我爱中国" << endl;
    return 0;
}
```

# 二：数据共享问题分析
##（2.1）只读数据：安全，不需要什么处理手段。直接读就可以；
##（2.2）有读有写：2个线程写，8个线程读。肯定崩溃
最简单的不崩溃处理：读的时候不写，写的时候不读，2个线程不同时写，8个线程不同时读；
##（2.3）共享数据的保护案例代码
网络游戏服务器：两个线程，一个线程收集玩家命令（用一个数字代表），并把命令数据写到一个队列中。
另一个线程，从队列中取出玩家发送来的命令，解析，然后执行玩家需要的动作；
list：频繁的按顺序插入和删除数据时效率高
vector：随机的插入和删除数据时效率高

# 第五节
## （1）互斥量
 互斥量是一个对象，理解成一把锁，多个线程尝试lock()这把锁，只有一个线程锁定成功
 使用时要小心，保护数据不多也不少，少了达不到保护效果。多了，影响效率；
## （2）用法
### （2.1）lock() unlock()
 步骤：先lock()--->操作共享数据--->unlock()
 使用原则：要成对使用，有lock()必然要有unlock()
### （2.2）std::lock_guard: 类模板，忘记unlock(),它替你lock();直接取代Lock()和unlock(),不能在继续使用lock和unlock了
## 三：死锁
### (3.1)死锁至少有两个锁头
### (3.2)解决方案：只要保证两个互斥量上锁顺序一致（不出现交叉），就不会导致死锁；lock_guard也一样！
### (3.3)std::lock()函数模板,但没需要unlock
 能力：可以一次锁定多个锁头（至少两个,一个不行）
 如果一个没锁住，他就在那里等着，等所有都锁住，才往下走。
 要么两个互斥量都锁定，要么都没锁定。如果只锁定了一个，另一个没锁定成功，他会立即解锁锁定了的额，然后专门去锁定没锁定的。
### (3.4)lock_guard的std::adopt_lock
 std::lock_guard<std::mutex> my_guard1(my_mutex1, std::adopt_lock);
 my_guard1的构造会调用lock()函数，加入std::adopt_lock表示构造时已经调用过lock()过了，my_guard1的构造不再需要调用lock()
 析构时照常调用unlock()

# 第六节
## (1)unique_lock取代lock_guard

## (2)unique_lock的第二个参数
### (2.1) std::adopt_lock
### (2.2) std::try_to_lock
### (2.3) std::defer_lock

## (3)unique_lock的成员函数
### (3.1) lock()
### (3.2) unlock()
### (3.3) try_lock()
### (3.4) release()

## (4)unique_lock所有权的传递

