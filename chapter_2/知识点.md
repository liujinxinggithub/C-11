# 一： 创建和等待多个线程
```c++
void myprint(int inum) {
    cout << "myprint线程开始执行了,线程编号=" << inum << endl;
}

int main() {
    //一：创建和等待多个线程
    vector<thread> mythreads;
    // 创建10个线程，入口统一使用myprint
    // a)10线程还行顺序时乱的，和操作系统对内部线程的运行调度机制有关
    // b)使用迭代器创建多个线程的写法需要记忆（对管理大量线程很方便）
    mythreads.reserve(10);
    for (int i = 0; i < 10; ++i) {
        mythreads.emplace_back(myprint, i);
    }

    for (auto &mythread : mythreads) {
        mythread.join();
    }
    cout << "我爱中国" << endl;
    return 0;
}
```

# 二：数据共享问题分析
##（2.1）只读数据：安全，不需要什么处理手段。直接读就可以；
##（2.2）有读有写：2个线程写，8个线程读。肯定崩溃
最简单的不崩溃处理：读的时候不写，写的时候不读，2个线程不同时写，8个线程不同时读；
##（2.3）共享数据的保护案例代码
网络游戏服务器：两个线程，一个线程收集玩家命令（用一个数字代表），并把命令数据写到一个队列中。
另一个线程，从队列中取出玩家发送来的命令，解析，然后执行玩家需要的动作；
list：频繁的按顺序插入和删除数据时效率高
vector：随机的插入和删除数据时效率高






