# 一： 创建和等待多个线程
```c++
void myprint(int inum) {
    cout << "myprint线程开始执行了,线程编号=" << inum << endl;
}

int main() {
    //一：创建和等待多个线程
    vector<thread> mythreads;
    // 创建10个线程，入口统一使用myprint
    // a)10线程还行顺序时乱的，和操作系统对内部线程的运行调度机制有关
    // b)使用迭代器创建多个线程的写法需要记忆（对管理大量线程很方便）
    mythreads.reserve(10);
    for (int i = 0; i < 10; ++i) {
        mythreads.emplace_back(myprint, i);
    }

    for (auto &mythread : mythreads) {
        mythread.join();
    }
    cout << "我爱中国" << endl;
    return 0;
}
```

# 二：数据共享问题分析
##（2.1）只读数据：安全，不需要什么处理手段。直接读就可以；
##（2.2）有读有写：2个线程写，8个线程读。肯定崩溃
最简单的不崩溃处理：读的时候不写，写的时候不读，2个线程不同时写，8个线程不同时读；
##（2.3）共享数据的保护案例代码
网络游戏服务器：两个线程，一个线程收集玩家命令（用一个数字代表），并把命令数据写到一个队列中。
另一个线程，从队列中取出玩家发送来的命令，解析，然后执行玩家需要的动作；
list：频繁的按顺序插入和删除数据时效率高
vector：随机的插入和删除数据时效率高

# 第五节
## （1）互斥量
 互斥量是一个对象，理解成一把锁，多个线程尝试lock()这把锁，只有一个线程锁定成功
 使用时要小心，保护数据不多也不少，少了达不到保护效果。多了，影响效率；
## （2）用法
### （2.1）lock() unlock()
 步骤：先lock()--->操作共享数据--->unlock()
 使用原则：要成对使用，有lock()必然要有unlock()
### （2.2）std::lock_guard: 类模板，忘记unlock(),它替你lock();直接取代Lock()和unlock(),不能在继续使用lock和unlock了
## 三：死锁
### (3.1)死锁至少有两个锁头
### (3.2)解决方案：只要保证两个互斥量上锁顺序一致（不出现交叉），就不会导致死锁；lock_guard也一样！
### (3.3)std::lock()函数模板,但没需要unlock
 能力：可以一次锁定多个锁头（至少两个,一个不行）
 如果一个没锁住，他就在那里等着，等所有都锁住，才往下走。
 要么两个互斥量都锁定，要么都没锁定。如果只锁定了一个，另一个没锁定成功，他会立即解锁锁定了的额，然后专门去锁定没锁定的。
### (3.4)lock_guard的std::adopt_lock
 std::lock_guard<std::mutex> my_guard1(my_mutex1, std::adopt_lock);
 my_guard1的构造会调用lock()函数，加入std::adopt_lock表示构造时已经调用过lock()过了，my_guard1的构造不再需要调用lock()
 析构时照常调用unlock()

# 第六节
## (1)unique_lock取代lock_guard
// unique_lock是一个类模板，在工作中，一般用lock_guard（推荐使用）；
// unique_lock比lock_guard灵活很多；效率上差一点，内存占用多一点
## (2)unique_lock的第二个参数
// std::lock_guard可以带第二个参数
// std::lock_guard<std::mutex> my_guard1(my_mutex1, std::adopt_lock);
### (2.1) std::adopt_lock
//（2.1）std::adopt_lock：表示互斥量已经被lock了（你必须提前lock互斥量，否则报异常）
// std::adopt_lock标记的效果就是“假设调用方线程已经拥有了互斥的所有权（已经lock成功）”；
// 通知lock_guard不需要在构造函数中lock这个互斥量了；
// unique_lock也可以带std::adopt_lock标记，含义相同。就是不希望在unique_lock的构造函数中继续lock
### (2.2) std::try_to_lock
// 我们会尝试用mutex的lock()去锁定这个mutex,但是如果没有成功，我也会立即返回，并不会阻塞在那里；
// 用这个try_to_lock的前提是你不可以先去lock
### (2.3) std::defer_lock
// 前提：不可以自己先lock，否则会报异常
// std::defer_lock：是初始化了一个没有加锁的mutex
## (3)unique_lock的成员函数
//（3.1）lock()，之后离开作用域后，不需要手动unlock
//（3.2）unlock(),可能有一些别的非共享代码要处理。先解锁，处理非共享代码，然后再次lock，去处理共享数据
//（3.3）try_lock()。尝试给互斥量枷锁，成功返回true，失败false
//（3.4）release()。返回它管理的mutex对象指针，并释放所有权；也就是说，这个unique_lock和mutex不在有关系；
// 严格区分unlock()和release()的关系，不要混淆。
// 如果mutex处理加锁状态。你要有责任接管过来，并负责解锁
粒度越细，效率越高！
## (4)unique_lock所有权的传递 (绑定mutex)

# 第七节
## 一：设计模式大概谈
// “设计模式”：代码的一些写法，程序灵活，维护起来方便。

## 二：单例模式（使用频率高）
// 单例：整个项目中，有某个类只能创建一个！
//    MyCAS *p_a = MyCAS::GetInstance(); // 创建一个对象，返回该类对象的指针
//    MyCAS *p_b = MyCAS::GetInstance();
//    p_a->func(); //该装载的数据装载
//    MyCAS::GetInstance()->func();

## 三：单例设计模式共享数据问题分析、解决
//        if (m_instance_ == nullptr) { // 双重锁定
//            std::unique_lock<std::mutex> my_mutex(resource_mutex); //自动加锁，只有第一次调用时才进来
//            if (m_instance_ == nullptr) {
//                m_instance_ = new MyCAS;
//                static CGarbageCollect cl;
//            }
//        }

## 四：std::call_once(); c++11,该函数第二个参数是函数名a();
// 功能：保证a()只能被调用一次
// 具备互斥量的能力，效率上更高效，消耗资源更少：
// 需要和标记std::once_flag结合使用
// 调用后改变std::once_flag的状态“已调用”
# 第八节 condition_variable、wait、notify_one、notify_all
## 条件变量condition_variable、wait、notify_one、notify_all
std::condition_variable是一个类；  
```c++
std::mutex mymutex1;
std::unique_lock<std::mutex> sbguard1(mymutex1);
std::condition_variable condition;
condition.wait(sbguard1, [this] {if (!msgRecvQueue.empty())
                                    return true;
                                return false;
                                });
condition.wait(sbguard1);
```
wait()用来等待一个东西？  
wait()第二个参数返回false：解锁互斥量(unlock)，并组赛到本行；阻塞到其他某个线程调用notify_one()成员函数为止；  
wait()第二个参数返回true，那么wait()直接返回并继续执行；  
如果没有第二个参数，那么效果跟第二个参数lambda表达式返回false效果一样,wait()将解锁互斥量，并阻塞到本行，阻塞到其他某个线程调用notify_one()成员函数为止。  
其他线程用notify_one()将本线程wait()唤醒后，这个wait恢复后  
1、wait()不断尝试获取互斥量锁，如果获取不到那么流程就卡在wait()这里等待获取，如果获取到了，那么wait()就继续执行，获取到了锁  
2.1、如果wait有第二个参数就判断这个lambda表达式。  
a)如果表达式为false，那wait又对互斥量解锁，然后又休眠，等待再次被notify_one()唤醒  
b)如果lambda表达式为true，则wait返回，流程可以继续执行（此时互斥量已被锁住）。  
2.2、如果wait没有第二个参数，则wait返回，流程走下去。  
流程只要走到了wait()下面则互斥量一定被锁住了。  
## notify_all()
notify_one()：通知一个线程的wait()  
notify_all()：通知所有线程的wait()



